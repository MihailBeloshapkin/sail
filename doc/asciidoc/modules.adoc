=== Modules
:simplemod: module_sail_doc/simple_mod.json

Sail provides support for organizing large specifications into
_modules_. Modules provide an access control mechanism, meaning a Sail
definition in one module cannot access or use definitions provided by
another module unless it explicitly _requires_ the other module.

The module structure of a Sail specification is specified in a
separate `.rigging` file (so named because
https://en.wikipedia.org/wiki/Rigging[rigging] is what supports and
organizes the sails on a ship).

For a simple example, let's assume we have two Sail files `amod.sail` and
`bmod.sail`:

.`amod.sail`
[source,sail]
----
include::sail:ALFA[from=simplemod,type=span]
----

.`bmod.sail`
[source,sail]
----
include::sail:BRAVO[from=simplemod,type=span]
----
We can use the following rigging file:

.`simple_mod.rigging`
[source]
----
include::module_sail_doc/simple_mod.rigging[]
----
This file defines two modules `A` and `B`, with module `A` containing
the file `amod.sail` and module B containing the file `bmod.sail`.
Module `B` requires module `A`, so it can use the `alfa` function
defined in `A`. What would happen if we removed the requires line? We
would get the following error:

[source]
----
include::module_sail_doc/simple_mod_err.error[]
----

This error tells us that `alfa` is not in scope, but Sail knows it
exists as it has already checked module `A`, so it points us at the
definition and suggests how we could resolve the error by adding the
requires line we just removed.

When using a rigging file we do not have to pass all the files on the
command line, so we can invoke Sail simply as

[source,shell]
----
sail simple_mod.rigging
----

and it will know where to find `amod.sail` and `bmod.sail` relative to
the location of the rigging file.

A module can have more than one Sail file. These files are processed
sequentially in the order they are listed. This is exactly like what
happens when we pass multiple Sail files on the command line without a
rigging file to define the module structure. A module can therefore be
thought of as a sequence of Sail files that is treated as a single
logical unit. As an example, we could add a third module to our above
file, which is comprised of three Sail files and depends on A and B.

[source]
----
C {
  requires A, B
  files
    foo.sail,
    bar.sail,
    baz.sail
}
----

Note that comments and trailing commas are allowed, and we could optionally delimit
the lists using `[` and `]`, like so:

[source]
----
C {
  // Require both our previous modules
  requires [A, B]
  /* Both types of Sail comments are allowed! */
  files [
    foo.sail,
    bar.sail,
    baz.sail,
  ]
}
----

If we wanted to we could define `C` in a separate file, rather than
adding it to our previous file, and pass multiple rigging files to
Sail like so:

[source,shell]
----
sail simple_mod.rigging new_file_with_C.rigging
----

These will be treated together as a single large rigging file. A use
case might be if you were defining an out-of-tree extension `Xfoo` for
sail-riscv, you could do something like:

[source,shell]
----
sail sail-riscv/riscv.rigging src/Xfoo.rigging
----

and the modules you define in `Xfoo.rigging` can require modules from
`riscv.rigging` (and technically also vice-versa, although it makes
less sense in this example).

=== Working with Makefiles

The `-list_files` option can be used to list all the files within a
rigging file, which allows them to be used in a Makefile prerequisite.
As an example, to build the module examples in this very manual, we
use the rule below to generate documentation indexes (which our
Asciidoctor plugin consumes) for every `.sail` file within a rigging
file.

[%nowrap,make]
----
.SECONDEXPANSION:

module_sail_doc/%.json: ../examples/%.rigging $$(shell sail ../examples/%.rigging -list_files)
	mkdir -p module_sail_doc
	sail -doc $(addprefix -doc_file ,$(shell sail $< -list_files)) -doc_embed plain -doc_bundle $(notdir $@) -o module_sail_doc $<
----

=== Conditional compilation within modules

We can use _variables_ in our rigging files to control either file
inclusion within a module or to control whether a module requires
another or not. A variable can even contain a sequence of modules,
that can then be used in a require statement, as shown in the
following example:

[source]
----
include::module_sail_doc/cond.rigging[]
----

=== Optional and default modules

Modules can be marked as either `optional` or `default`. Default
modules are those that form the base part of a specification, whereas
optional modules are intended to implement extensions which may or may
not be present. Default modules cannot require optional modules.
